Madoko documentation: http://madoko.org/reference.html

Title       : Coding standards for Azure C SDK
Title Note  : Version 1.0.0
Logo        : False
Embed       : False
css         : custom.css

[INCLUDE=../components.mdk]

[TITLE]

# Coding standards

The following C Programming Language coding standards have been adopted to ensure consistency and readability across all client libraries.
Some of this has been adapted from [C Coding Standard](http://www.cs.utah.edu/~tch/snets/SNETCCodingStandard.html).

## Naming standard
### Namespaces {#clang-namespaces}

C programming language does not have the concept of a namespace, similar to other programming languages, such as C++. However, we could achieve a similar behaviour by having external facing function and variable names follow this naming pattern
`az_<shortname>_<objname>_<functionname>()` where _shortname_ is the service name for the API represented as a single word and _objtname_ denotes a logical grouping of actions within the same area.<br/>Some examples:

```c
az_keyvault_key* az_keyvault_keyclient_create_key(char* info)
{

}
```

```c
az_eventhub_eph_process_partition(az_eventhub_partition_info* partition_info)
{

}

void az_iot_credential_init(az_iot_credential* credential)
{
    
}

void az_iot_credential_deinit(az_iot_credential* credential)
{

}

```

Please note, the function names in the examples are separated using underbars ('_') to follow the common naming convention recommended in the guidelines.

~ Must
prepend all exposed functions with `az` followed by '\_' and short name for the client library, followed by '\_' and object name (with appropriate casing for the situation).
~

~ Must
register the short name used by the client library with [adparch](https://github.com/Azure/azure-sdk-pr/issues/new/choose).
~

## Directory tree organization
The repo should follow the structure:

```
repo_name
    build_all
    config
        repo_name_config.h
    deps
        dep_1
        dep_2
        dep_n
    inc
        internal
    pal
    sample
        sample_1
        sample_2
        sample_n
    tests
        inc
        src
        lib_1_ut
        lib_2_ut
        lib_n_ut
        test_a_e2e
        test_b_e2e
        test_c_lh
        test_d_lh
    src
        lib_1
        lib_2
        lib_n
    LICENSE
    README.md
```

Where:

* **build_all**: Contains the scripts to build the project.

* **config**: Contains the user configuration, it contains a default config that the user should copy and modify to create its own set of configurations.

* **deps**: Contains the repo dependencies, normally github submodules.

* **inc**: Contains the includes of the repo, all files on the root are the public API and should be part of the LTS (Long Term Support). The files in the `internal` are the ones that contains the signature of methods and data structs that are not part of 
the public API and Microsoft can change it without any previous note. The `internal` should not be part of the include path, include an internal file should always contains the internal path in the name, (ex: `#include “internal/bar_non_public.h”`).

* **pal**: Contains the files with the port specific code.

* **sample**: Contains samples and tutorials that users will use as reference to learn how to use the code in the repo.

* **tests**: Contains the files with the tests for the libs (target code in the repo), each lib must have **ut** (unit test), it is very recommend to add **e2e** (end to end test), and **lh** (longhaul test) as well.

* **LICENSE**: Is the file that describe the license of the code in the repo.

* **README.md**: Is the file with the generic description of the repo, it can contain links for the lib documentation

## Files

~ Must
use standard extensions for files.  Use the `.h` extension for header files and `.c` for source files.
~

~ Must
use header file guards.

```c
#ifndef IOT_CLIENT_H
#define IOT_CLIENT_H

/* Contents of iot_client.h */

#endif /* IOT_CLIENT_H */
```
~

### File names

~ Must
follow these guidelines when naming files:

* All file names should be full lowercase to avoid casing issues across platforms.

* A source (`.c`) filename should be made of the shortname, followed by the objectname. 
  *Example*: `iot_credential.c`

* Words in file names should be separated by `_`. 

* The public API should be clearly identified with the shortname followed by the object name and the name `api` 
 * *Example*: `iot_credential_api.h`

* An include (`.h`) that is not part of the public API should be placed in the `internal` directory, and shall not contains the shortname on the name. The path `internal` should not be included as standard include directory.
 * *Example*: `internal/credential.h`

* The file name should use characters `a` to `z`, `0` to `9`, `_` (underscore) as name separator, and one `.` before the file extension. All other characters are not allowed. 

* Filenames should be concise enough, but they should convey the information of what the file contains. 

 **Bad**: `ih.c`, `the_iot_hub_client_thingie.c` 

 **Good**: `iot_memorymanager_byte_malloc.c`
~

### Copyright
All files should start with the copyright information:

```c
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
```

## General naming conventions

~ Must
use clear and concise names.
~

~ShouldNot
use abbreviations unless necessary or when they are commonly used; e.g. `az_iot` can be used because `az` is a common abbreviation for Azure and `iot` is common enough.
~

~ Must
use lower-case for all variable and function names.
~

~ Must
use underbars ('_') to separate name components (snake-casing).
~

~ Must
use a single leading underscore to indicate that a name is not part of the public API and is not guaranteed to be stable.
~

~ Must
place the `*` next to the variable name to indicate a pointer type.  i.e. use `char *name = NULL;`, not `char* name = NULL;`.
~

~ Must 
include units in names.

If a variable represents time, weight, or some other unit then include the unit in the name so developers can more easily spot problems. For example:

```c
uint32 timeout_msecs;
uint32 my_weight_lbs;
```
~

~ Must
declare variables in structures organized by use in a manner to attempt to minimize memory wastage because of compiler alignment issues, then by size, and then by alphabetical order.

For example, don't use the following:

```c
struct foo {
    int a;
    char *b;
    int c;
    char *d;
};
```

Do use:

```c
struct foo {
    int a;
    int c;
    char *b;
    char *d;
};
```

Each variable get its own type and line, although an exception can be made when declaring bitfields (to clarify that it's part of the one bitfield).  The use of bitfields in general is discouraged.
~

~ Must
declare major structures at the top of the file in which they are used, or in separate header files if they are used in multiple source files.  
Use of the structures should be by separate declarations should be "extern" if they are declared within a header file.
~

~ ToDo
Should we use a meaningful prefix for each member name or for structures in general?
~

~ ShouldNot
use global variables.  Global variables should be avoided whenever possible.  If absolutely necessary, declare them at the top of your files and prepend global variables with `g_`.
~

~ Must
name global constants using upper-case and snake-casing.  For example, `const int GLOBAL_CONSTANT = 5;`.
~

~ Must
name enum types using pascal-casing.  The values within an enum must be upper-case and snake-cased.  There must not be a comma on the last element.  

For example:

```c
enum PinStateType {
    PIN_OFF,
    PIN_ON
};
```
~

~ Must
be aware that enums are not of a guaranteed size.  If you have a type that can take a known range of values and it is transported in a message, you cannot use an enum as a type.
~

~ Must
make a label for an error state and make it the first label.  It is often useful to be able to say an enum is not in any of its valid states.

For example:

```c
enum service_state { 
    STATE_ERR, 
    STATE_OPEN, 
    STATE_RUNNING, 
    STATE_DYING 
};
```
~

## Functions

~ Must
use full lowercase name for the functions. The words should be separated by `_`. 
```c
int64_t bar_add(int32_t a, int32_t b);
```
~

~ Must 
have functions in the public API start with the shortname followed by the objectname name and the function name. The definition of the function should be placed in the *xx_api.h* file of the module (for the below example, the *az_iot_barclass_api.h*). 
```c
az_iot_result az_iot_barclass_init(az_iot_result *my_barclass, 
        const char* const name, uint32_t entry, void* buffer_start, 
        size_t buffer_size, uint8_t priority);
```
A public API that should be implemented in multiple flavors, should have the flavors with the same name of the public API preceded by `_`. For the flavor without argument validation, the name should be the same of the public API followed by `_no_test`. For example, the two flavors of `az_iot_credential_create_from_connection_string` should be: 
```c
/**
 * @brief   Create a credential component from connection string.
 */
static inline az_iot_ulib_result az_iot_credential_create_from_connection_string(
    az_iot_credential *credential,
    const char* const connection_string)
{
#if AZIOT_CREDENTIAL_VALIDATE_ARGUMENTS
    return _az_iot_credential_create_from_connection_string(
        credential,
        connection_string);
#else
    return _az_iot_credential_create_from_connection_string_no_test(
        credential,
        connection_string);
#endif /* AZIOT_CREDENTIAL_VALIDATE_ARGUMENTS */
}
```
~

~ Should
set as `static` all functions whose purpose is only inside of the source code (`.c`) . The static function should contain only the function name, without any prefix. For example:
```c
static int64_t sum(int32_t a, int32_t b)
{
    return (int64_t)a + (int64_t)b;
}
```
~

## Variables
~ Must
use full lowercase names for variables separated by `_`.
Global variables should start with `g_` followed by the namespace, and the variable name. **Global variables should be strongly avoided**. 
```c
uint32_t g_aziot_byte_counter;
```
~

~ Must
start variables that are not `static` but not part of the public API should start with `_` followed by the shortname, the objectname, and the variable name.
The definition of the variable should be placed in the header file of the module, inside of the `internal` directory. **These variable should be strongly avoided**. 

```c
uint32_t _az_iot_bar_byte_counter;
```
~

~ Should 
set as `static` variables whose propose is only inside of the source code (`.c`) . The static variable should not have any prefix, only the variable name.
```c
static uint32_t byte_counter = 10;
```
~

~ Must 
use a fully lowercase name separated by `_`, without any prefix, for arguments and local variable names; e.g. 

```c
static az_iot_bar_result call_procedure(
    const char* const name, 
    const void* const procedure_model_in, 
    const void* procedure_model_out);
{
    uint32_t byte_counter = 10;
    ...
}
```
~

## Structures
Structures should be defined with typedef, the structure name should be lowercase with `_` separator. They should follow the same naming conventions and variables and functions; i.e. should start with `az_shortname_objectname'. 
Only declarations should be part of the header files. A typical definition might look like:


```c
/* Header file: iot_client_api.h */

#ifndef IOT_CLIENT_API_H
#define IOT_CLIENT_API_H

typedef struct az_iot_client az_iot_client;
typedef struct az_iot_client_credentials az_iot_client_credentials;

/* Rest of the declarations */

#endif /* IOT_CLIENT_API_H */

/* Source file: iot_client_api.c */

#include "iot_client_api.h"

typedef struct az_iot_client {
	char *api_version;
	az_iot_client_credentials *credentials;
	int long_running_operation_retry_timeout;
} az_iot_client;

typedef struct az_iot_client_credentials {
	char *version;
	/* remaining struct members here */
} az_iot_client_credentials;

```

## Callbacks
Functions that request a callback with a context should ordering the callback first and than the callback context. For example:
```c
az_iot_client az_iot_client_send_async(az_iot_client *client, 
        az_iot_message *message, az_iot_release_callback release_message, 
        az_iot_client_result_callback callback, az_iot_client_result_context context)
```

All callbacks that has context should receive the context as the first argument. For example:
```c
static void on_client_result(az_iot_client_result_context context, 
        az_iot_result result, az_iot_message_received message)
```


## Macros

~ Must
name `#define` macros upper-case using snake-casing.  Macros are capitalized, parenthesized, and must avoid side-effects.  If the macro is an inline expansion of a function, the function is defined all in lowercase and the macro must have the same name in uppercase.  If the macro is an expression, wrap the expression in parenthesis.

Note: some subtle errors can occue when macro names and enum labels use the same name.

Examples:

```c
#define MAX(a,b) ((a > b) ? a : b)
#define IS_ERR(err) (err < 0)
```
~

~ Should
wrap a macro in `do { .... } while (0)` if the macro is more than a single statement, so that a trailing semicolon works.  Right-justify backslashes to ensure the macro is easier to read.

Example:

```c
#define MACRO(v, w, x, y)           \
do {                                \
    v = (x) + (y);                  \
    w = (y) + 2;                    \
} while (0)
```
~

~ MustNot
change syntax via macro substitution.  It [makes the program unintelligible](https://gist.github.com/aras-p/6224951) to all but the perpetrator.
~

~ Should
replace macros with inline functions.  In C, macros are not needed for code efficiency.  

Example, instead of `#define MAX(x,y) (((x) > (y) ? (x) : (y)))`, use the following:

```c
inline int max(int x, int y) { 
    return (x > y ? x : y);
}
```
~

~ Must
be careful of side effects in macros.  For example, using the following with the preceding macro would cause side effects:  `MAX(f(x),z++);`.
~

~ Must
wrap the macro expression in parenthesis.  This avoids potential communitive operation ambiguity.
~

~ Must
make macro names unique.  Like global variables, macros can conflict with macros from other packages.  Prepend macro names with package names, and avoid simple and common names like `MAX` and `MIN`.
~

## Formatting


~ Must
use [clang-format](http://clang.llvm.org/docs/ClangFormat.html) for formatting, using the following command-line options:

```bash
clang-format -style=llvm -i <file> ...
```
~

In general, clang-format will format your code correctly and ensure consistency. However, these are few additional  rules to keep in mind.

~ Must
place all conditional or loop statements on one line, or add braces to identify the conditional/looping block.
~

~ Must
add comments to closing braces.  Adding a comment to closing braces can help when you are reading code because you don't have to find the begin brace to know what is going on.

```c
while (1) {
    if (valid) {
        ...
    } /* if valid */
    else {

    } /* not valid */
} /* end forever */
```
~

~ Must
add comments to closing preprocessor to make it easier to understand it, example:.

```c
#if _BEGIN_CODE_

#ifndef _INTERNAL_CODE_

#endif /* _INTERNAL_CODE_ */

#endif /* _BEGIN_CODE_ */
```
~

~ Should
consider screen size limits.  Most people like blocks to fit within a common screen size so scrolling is not necessary when reading code.  Lines should not exceed 120 characters, and blocks should not exceed 40 lines.
~

~ MustNot
put parens next to keywords.  Put a space between the keyword and the paren.
~

~ Must
put parens next to function names.
~

~ ShouldNot
use parens in return statements when it isn't necessary.
~

~ Must
place each segment of an `if`/`then`/`else` statement on a separate line if you have a block.  If you include `else if` statements, ensure you also add an `else` block for finding unhandled cases.

Example:

```c
if (valid) {
    ...
} /* if valid */
else {

} /* not valid */
```
~

~ Must
place the constant on the left hand side of an eqality/inequality comparison (yoda style).  For example, `if (6 == errNum) ...`.
~

~ Must
include a comment for falling through a `case` statement.
~

~ Must
include a `default` case when using a `switch` statement.
~

~ Must
place all code for a `case` statement in a block if you need to create variables.
~

Example of a switch statement:

```c
switch (...) {
    case 1:
        do_something();
        break;
    case 2:
        do_something_else();
        /* fall through */
    case 3: 
        {
            int v;

            do_something_more(v);
        }
        break;
    default:
        log(LOG_DEBUG, "default case reached");
}
```

~ ShouldNot
use `goto` statements.  The main place where `goto` statements can be usefully employed is to break out of several levels of `switch`, `for`, or `while` nesting, although the need to do such a thing may indicate that the inner constructs should be broken out into a separate function with a success/failure return code.  When a `goto` is necessary, the accompanying label should be alone on a line and to the left of the code that follows.  The `goto` should be commented as to its utility and purpose.
~

~ Should
use `continue` and `break` sparingly.  These statements are really disguised `goto` statements.
~

~ MustNot
use a ternary operator unless it is really clear what it does.  Put the condition in parens (so as to set it off from other code).  If possible, the actions for the test should be simple functions.  Put the action for the `then` and `else` statement on a separate line unless it can be clearly put on one line.
~

~ Must
place only one statement on each line.
~

## Complexity Management

~ Must
initialize all variables. Use of compiler flags (such as `gcc -Wall` or `cl.exe /W4`) may catch operations on uninitialized variables.
~

~ Must
limit function bodies to one page of code (40 lines, approximately).
~

~ Must
document null statements.  Always document a null body for a `for` or `while` statement so that it is clear the null body is intentional.
~

~ Must
use explicit comparisons when testing for failure.  Use `if (FAIL != f())` rather than `if (f())`.  Even though FAIL may have the value 0 which C considers to be false.  An explicit test will help you out later when somebody decides that a failure return should be -1 instead of 0.  

Explicit comparison should be used even if the comparison value will never change.  e.g. `if (!(bufsize % sizeof(int)))` should be written as `if (0 == (bufsize % sizeof(int))` to reflect the numeric (not boolean) nature of the test.  

A frequent trouble spot is using `strcmp` to test for string equality.  You should **never** use a default action.  The preferred approach is to use an inline function:

```c
inline bool string_equal(char *a, char *b) {
    return (strcmp(a, b) == 0);
}
```
~

~ Should
avoid embedded assignments.  There is a time and a place for embedded assignment statements.  In some constructs, there is no better way to accomplish the results without making the code bulkier and less readable.

```c
while (EOF != (c = getchar())) {
    /* process the character */
}
```

However, one should consider the tradeoff between increased speed and decreased maintainability that results when embedded assignments are used in artificial places.
~

## Miscellaneous

~ Should
avoid layering jumps.  

Layering is the primary technique for reducing complexity in a system.  A system should be divided into layers.  Layers should communicate between adjacent layers using well defined interfaces.  When a layer uses a non-adjacent layer, then a layering violation has occurred.  This means we have a dependency between layers that is not controlled by a well defined interface.  When one of the layers changes, code could break.  Sometimes we need to jump layers for performance reasons.  This is reasonable, but we should be explicit about it and document appropriately.
~

~ MustNot
use floating-point variables where discrete values are needed. Using a float for a loop counter is a great way to shoot yourself in the foot. Always test floating-point numbers as <= or >=, never use an exact comparison (== or !=).
~

~ MustNot
write around compiler bugs.  Compilers have bugs. Common trouble spots include structure assignment and bit fields. You cannot generally predict which bugs a compiler has. You could write a program that avoids all constructs that are known broken on all compilers. You won't be able to write anything useful, you might still encounter bugs, and the compiler might get fixed in the meanwhile. Thus, you should write ``around'' compiler bugs only when you are forced to use a particular buggy compiler.
~

~ MustNot
rely on automatic beautifiers. The main person who benefits from good program style is the programmer him/herself, and especially in the early design of handwritten algorithms or pseudo-code. Automatic beautifiers can only be applied to complete, syntactically correct programs and hence are not available when the need for attention to white space and indentation is greatest. Programmers can do a better job of making clear the complete visual layout of a function or file, with the normal attention to detail of a careful programmer (in other words, some of the visual layout is dictated by intent rather than syntax and beautifiers cannot read minds). Sloppy programmers should learn to be careful programmers instead of relying on a beautifier to make their code readable. Finally, since beautifiers are non-trivial programs that must parse the source, a sophisticated beautifier is not worth the benefits gained by such a program. Beautifiers are best for gross formatting of machine-generated code.
~

~ MustNot
use implicit assignment inside a test.  This is generally an accidental omission of the second `=` of the logical compare. The following is confusing and prone to error.
    
```c
if (a = b) { ... }
```

Does the programmer really mean assignment here? Often yes, but usually no. The solution is to just not do it, an inverse Nike philosophy. Instead use explicit tests and avoid assignment with an implicit test. The recommended form is to do the assignment before doing the test:

```c
a = b;
if (a) { ... } 
```
~

~ Must
use the register sparingly to indicate the variables that you think are most critical.  Modern compilers will put variables in registers automatically.  In extreme cases, mark the 2-4 most critical values as `register` and mark the rest as `REGISTER`. The latter can be `#defined` to register on those machines with many registers.
~

~ Must
be `const` correct.  C provides the `const` keyword to allow passing as parameters objects that cannot change to indicate when a method doesn't modify its object. Using `const` in all the right places is called "const correctness." It's hard at first, but using `cons`t really tightens up your coding style. Const correctness grows on you.
~

~ Must
use `#if` instead of `#ifdef`.  Someone might write code like:

```c
#ifdef DEBUG
    temporary_debugger_break();
#endif
```

Someone else might compile the code with turned-of debug info like:

```c
cc -c lurker.cc -DDEBUG=0
```

Alway use `#if` if you have to use the preprocessor. This works fine, and does the right thing, even if `DEBUG` is not defined at all (!)

```c
#if DEBUG
    temporary_debugger_break();
#endif
```

If you really need to test whether a symbol is defined or not, test it with the `defined()` construct, which allows you to add more things later to the conditional without editing text that's already in the program:

```c
#if !defined(USER_NAME)
 #define USER_NAME "john smith"
#endif
```
~

~ Must
Use `#if` to comment out large code blocks.

Sometimes large blocks of code need to be commented out for testing.  The easiest way to do this is with an `#if 0` block:

```c
void example()
{
    great looking code

    #if 0
    lots of code
    #endif

    more code
}
```

You can't use `/**/` style comments because comments can't contain comments and surely a large block of your code will contain a comment, won't it?

Don't use `#ifdef` as someone can unknowingly trigger ifdefs from the compiler command line. 

`#if 0` is that even a day later you or anyone else has to know idea why this code is commented out. Is it because a feature has been dropped? Is it because it was buggy? It didn't compile? Can it be added back? It's a mystery.  Use descriptive macro names instead of `#if 0`

```c
#if NOT_YET_IMPLEMENTED  
#if OBSOLETE
#if TEMP_DISABLED
```

Always add a short comment explaining why it is commented out.
~

~ MustNot
put data definition in header files.  For example, this should be avoided:

```c
/* aheader.h */
int x = 0;
```

It's bad magic to have space consuming code silently inserted through the innocent use of header files.  It's not common practice to define variables in the header file, so it will not occur to developers to look for this when there are problems.  Consider, instead, defining the variable once in a source file and then use an `exten` statement to reference it.
~

~ MustNot
use magic nunmbers. A magic number is a bare naked number used in source code. It's magic because no-one has a clue what it means including the author inside 3 months. For example:

```c
if      (22 == foo) { start_thermo_nuclear_war(); }
else if (19 == foo) { refund_lotso_money(); }
else if (16 == foo) { infinite_loop(); }
else                { cry_cause_im_lost(); }
```

In the above example what do 22 and 19 mean? If there was a number change or the numbers were just plain wrong how would you know? Instead of magic numbers use a real name that means something. You can use `#define` or constants or enums as names. Which one is a design choice. For example:

```c
#define   PRESIDENT_WENT_CRAZY  (22)
const int WE_GOOFED= 19;
enum  {
   THEY_DIDNT_PAY= 16
};

if      (PRESIDENT_WENT_CRAZY == foo) { start_thermo_nuclear_war(); }
else if (WE_GOOFED            == foo) { refund_lotso_money(); }
else if (THEY_DIDNT_PAY       == foo) { infinite_loop(); }
else                                  { happy_days_i_know_why_im_here(); }
```

The `const` and `enum` options are preferable because when debugging the debugger has enough information to display both the value and the label. The `#define` option just shows up as a number in the debugger which is very inconvenient. The `const` option has the downside of allocating memory. Only you know if this matters for your application.
~

~ Must
check every system call for an error return, unless you know you wish to ignore errors. For example, `printf` returns an error code but rarely would you check for its return code. Ccast the return to (void) if you really do not care.

```c
(void)printf("The return type is ignored");
```
~

~ Must
include the system error text when reporting every system error message.
~

~ Must
check every call to `malloc` or `reallo`c unless you know your versions of these calls do the right thing. You might want to have your own wrapper for memory allocation calls, so you can do the right thing always and developers don't have to make memory checks everywhere.
~